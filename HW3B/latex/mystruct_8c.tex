\section{mystruct.\+c File Reference}
\label{mystruct_8c}\index{mystruct.\+c@{mystruct.\+c}}
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include \char`\"{}mystruct.\+h\char`\"{}}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Employee} $\ast$ \textbf{ make\+Employee} (int birth, int start, const char $\ast$name)
\item 
void \textbf{ print\+Employee} (struct \textbf{ Employee} $\ast$e)
\item 
struct \textbf{ Employee} $\ast$ \textbf{ make\+Random\+Employee} ()
\item 
char $\ast$ \textbf{ generate\+Random\+Char} ()
\item 
char $\ast$ \textbf{ generate\+Random\+String} ()
\item 
struct \textbf{ Employee} $\ast$$\ast$ \textbf{ make\+Employee\+Array} (int count)
\item 
void \textbf{ print\+Employee\+Array} (struct \textbf{ Employee} $\ast$$\ast$e, int size)
\item 
struct \textbf{ Employee} $\ast$$\ast$ \textbf{ shallow\+Copy} (struct \textbf{ Employee} $\ast$$\ast$e, int size)
\item 
void \textbf{ free\+Array} (struct \textbf{ Employee} $\ast$$\ast$e, int size)
\item 
struct \textbf{ Employee} $\ast$ \textbf{ copy\+Employee} (struct \textbf{ Employee} $\ast$e)
\item 
struct \textbf{ Employee} $\ast$$\ast$ \textbf{ deep\+Copy} (struct \textbf{ Employee} $\ast$$\ast$e, int size)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\label{mystruct_8c_a0f98e6a5ec411e4f147f63c4acb3f808}} 
\index{mystruct.\+c@{mystruct.\+c}!copy\+Employee@{copy\+Employee}}
\index{copy\+Employee@{copy\+Employee}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{copy\+Employee()}
{\footnotesize\ttfamily struct \textbf{ Employee}$\ast$ copy\+Employee (\begin{DoxyParamCaption}\item[{struct \textbf{ Employee} $\ast$}]{e }\end{DoxyParamCaption})}

Deep copies the employee e into a new employee, that is to say all the data is the same but all the pointers to the data are different. 
\begin{DoxyParams}{Parameters}
{\em e} & the employee to deep copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a deep copied version of e 
\end{DoxyReturn}


References Employee\+::birth\+\_\+year, Employee\+::name, and Employee\+::start\+\_\+year.



Referenced by deep\+Copy(), and test\+Copy\+Employee().

\mbox{\label{mystruct_8c_a86fc52edbcaa4cbac4f49a894f010476}} 
\index{mystruct.\+c@{mystruct.\+c}!deep\+Copy@{deep\+Copy}}
\index{deep\+Copy@{deep\+Copy}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{deep\+Copy()}
{\footnotesize\ttfamily struct \textbf{ Employee}$\ast$$\ast$ deep\+Copy (\begin{DoxyParamCaption}\item[{struct \textbf{ Employee} $\ast$$\ast$}]{e,  }\item[{int}]{size }\end{DoxyParamCaption})}

Deep copies an array of employees into a new array of employees, where all the data is the same but new pointers to all that data. 
\begin{DoxyParams}{Parameters}
{\em e} & the employee array to deep copy \\
\hline
{\em size} & the size of the array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a deep copied version of e 
\end{DoxyReturn}


References copy\+Employee().



Referenced by test\+Deep\+Copy().

\mbox{\label{mystruct_8c_acd3779236deca69648e8e8f1c4630446}} 
\index{mystruct.\+c@{mystruct.\+c}!free\+Array@{free\+Array}}
\index{free\+Array@{free\+Array}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{free\+Array()}
{\footnotesize\ttfamily void free\+Array (\begin{DoxyParamCaption}\item[{struct \textbf{ Employee} $\ast$$\ast$}]{e,  }\item[{int}]{size }\end{DoxyParamCaption})}

Frees the interior content of an employee array, as well as e itself. 
\begin{DoxyParams}{Parameters}
{\em e} & the array to free \\
\hline
{\em size} & the size of the array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
none 
\end{DoxyReturn}


Referenced by test\+Deep\+Copy(), test\+Free\+Array(), test\+Make\+Employee\+Array(), test\+Print\+Employee\+Array(), and test\+Shallow\+Copy().

\mbox{\label{mystruct_8c_a641e968e8051dd361e5602e3a183d257}} 
\index{mystruct.\+c@{mystruct.\+c}!generate\+Random\+Char@{generate\+Random\+Char}}
\index{generate\+Random\+Char@{generate\+Random\+Char}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{generate\+Random\+Char()}
{\footnotesize\ttfamily char$\ast$ generate\+Random\+Char (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Generates a random printable character. 
\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the random character 
\end{DoxyReturn}


Referenced by generate\+Random\+String(), and test\+Generate\+Random\+Char().

\mbox{\label{mystruct_8c_a339d43068a43ca84610495fad9fe8757}} 
\index{mystruct.\+c@{mystruct.\+c}!generate\+Random\+String@{generate\+Random\+String}}
\index{generate\+Random\+String@{generate\+Random\+String}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{generate\+Random\+String()}
{\footnotesize\ttfamily char$\ast$ generate\+Random\+String (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Generates a random string from length of 0 to 20. The string pointer must be freed once the user is done with it. 
\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a random string 
\end{DoxyReturn}


References generate\+Random\+Char().



Referenced by make\+Random\+Employee(), and test\+Generate\+Random\+String().

\mbox{\label{mystruct_8c_a47ede2fced0227e67281196472097118}} 
\index{mystruct.\+c@{mystruct.\+c}!make\+Employee@{make\+Employee}}
\index{make\+Employee@{make\+Employee}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{make\+Employee()}
{\footnotesize\ttfamily struct \textbf{ Employee}$\ast$ make\+Employee (\begin{DoxyParamCaption}\item[{int}]{birth,  }\item[{int}]{start,  }\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\doxyref{mystruct.\+c}{p.}{mystruct_8c} \begin{DoxyAuthor}{Author}
Ravi Kirschner Allocates an \doxyref{Employee}{p.}{structEmployee} struct and fills in its fields 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em birth} & Year the employee was born. \\
\hline
{\em start} & Year the employee started with the company. \\
\hline
{\em name} & String containing employee\textquotesingle{}s name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to \doxyref{Employee}{p.}{structEmployee} struct, newly allocated from the heap. 
\end{DoxyReturn}


References Employee\+::birth\+\_\+year, Employee\+::name, and Employee\+::start\+\_\+year.



Referenced by make\+Random\+Employee(), test\+Make\+Employee(), and test\+Print\+Employee\+Array().

\mbox{\label{mystruct_8c_a3e9af8811445d0d7a5c9da0c40f63804}} 
\index{mystruct.\+c@{mystruct.\+c}!make\+Employee\+Array@{make\+Employee\+Array}}
\index{make\+Employee\+Array@{make\+Employee\+Array}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{make\+Employee\+Array()}
{\footnotesize\ttfamily struct \textbf{ Employee}$\ast$$\ast$ make\+Employee\+Array (\begin{DoxyParamCaption}\item[{int}]{count }\end{DoxyParamCaption})}

Generates an array of size count full of random employees. The \doxyref{Employee}{p.}{structEmployee} array must be freed once the user is done with it. 
\begin{DoxyParams}{Parameters}
{\em count} & the size of the array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the array filled with random employees. 
\end{DoxyReturn}


References make\+Random\+Employee().



Referenced by test\+Deep\+Copy(), test\+Free\+Array(), test\+Make\+Employee\+Array(), and test\+Shallow\+Copy().

\mbox{\label{mystruct_8c_a3a236a57a40387807c40bf62b5b8fe90}} 
\index{mystruct.\+c@{mystruct.\+c}!make\+Random\+Employee@{make\+Random\+Employee}}
\index{make\+Random\+Employee@{make\+Random\+Employee}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{make\+Random\+Employee()}
{\footnotesize\ttfamily struct \textbf{ Employee}$\ast$ make\+Random\+Employee (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Generates a random employee 
\begin{DoxyParams}{Parameters}
{\em nome} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a random employee struct 
\end{DoxyReturn}


References generate\+Random\+String(), make\+Employee(), and Employee\+::name.



Referenced by make\+Employee\+Array(), test\+Copy\+Employee(), and test\+Make\+Random\+Employee().

\mbox{\label{mystruct_8c_acff9aa9547982f1b0effbd6f302e325e}} 
\index{mystruct.\+c@{mystruct.\+c}!print\+Employee@{print\+Employee}}
\index{print\+Employee@{print\+Employee}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{print\+Employee()}
{\footnotesize\ttfamily void print\+Employee (\begin{DoxyParamCaption}\item[{struct \textbf{ Employee} $\ast$}]{e }\end{DoxyParamCaption})}

A function to print all the fields of an employee struct to the console 
\begin{DoxyParams}{Parameters}
{\em e} & the employee to print out \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
none 
\end{DoxyReturn}


References Employee\+::birth\+\_\+year, Employee\+::name, and Employee\+::start\+\_\+year.



Referenced by print\+Employee\+Array(), test\+Make\+Employee(), test\+Make\+Random\+Employee(), and test\+Print\+Employee().

\mbox{\label{mystruct_8c_a3d6137c1cd7db028f1c52265b218345f}} 
\index{mystruct.\+c@{mystruct.\+c}!print\+Employee\+Array@{print\+Employee\+Array}}
\index{print\+Employee\+Array@{print\+Employee\+Array}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{print\+Employee\+Array()}
{\footnotesize\ttfamily void print\+Employee\+Array (\begin{DoxyParamCaption}\item[{struct \textbf{ Employee} $\ast$$\ast$}]{e,  }\item[{int}]{size }\end{DoxyParamCaption})}

Prints an entire array of employees to the console. 
\begin{DoxyParams}{Parameters}
{\em e} & the array of employees to be printed \\
\hline
{\em size} & the size of the array e \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
none 
\end{DoxyReturn}


References print\+Employee().



Referenced by test\+Make\+Employee\+Array(), and test\+Print\+Employee\+Array().

\mbox{\label{mystruct_8c_abd1e3aa85dcf9bad8bb51b9547a0214f}} 
\index{mystruct.\+c@{mystruct.\+c}!shallow\+Copy@{shallow\+Copy}}
\index{shallow\+Copy@{shallow\+Copy}!mystruct.\+c@{mystruct.\+c}}
\subsubsection{shallow\+Copy()}
{\footnotesize\ttfamily struct \textbf{ Employee}$\ast$$\ast$ shallow\+Copy (\begin{DoxyParamCaption}\item[{struct \textbf{ Employee} $\ast$$\ast$}]{e,  }\item[{int}]{size }\end{DoxyParamCaption})}

Shallow copies an array of employee structs. That is to say, it makes a new array but the pointers inside of it are the same. 
\begin{DoxyParams}{Parameters}
{\em e} & the old array of Employees \\
\hline
{\em size} & the size of the old array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a new array of Employees with the same data as e but not the same pointers 
\end{DoxyReturn}


Referenced by test\+Shallow\+Copy().

